# 비트마스크
비트 마스킹은 데이터를 문자/정수/부동 소수점으로 저장하는 것이 아니라 실제로 비트로 저장하는 프로세스입니다. 특정 유형의 데이터를 콤팩트하고 효율적으로 저장하는 데 매우 유용합니다.

비트 마스킹에 대한 아이디어는 bool 논리를 기반으로 합니다. 익숙하지 않은 사람들을 위해 설명하자면 부울 논리는 논리 연산(0과 1을 인수로 사용)을 통해 '참'(1)과 '거짓'(0)을 조작하는 것입니다. 우리는 다음과 같은 작업에 관심을 두고 있습니다:

- NOT a - 최종 값은 입력 값과 반대입니다. (1 -> 0, 0 -> 1)
- a AND b - 두 값이 모두 1이면 최종 값은 1이고, 그렇지 않으면 최종 값은 0입니다.
- a OR b - 둘 중 하나의 값이 1이면 최종 값은 1이고, 그렇지 않으면 최종 값은 0입니다.
- a XOR b - 한 값이 1이고 다른 값이 0이면 최종 값은 1이고, 그렇지 않으면 최종 값은 0입니다.

컴퓨팅에서는 이러한 참/거짓 값 중 하나가 비트입니다. C의 프리미티브(int, float 등)는 특정 개수의 비트로 구성되며 해당 숫자는 8의 배수입니다. 예를 들어 int의 크기는 최소 16비트일 수 있고 char의 크기는 8비트일 수 있습니다. 8비트를 일반적으로 바이트라고 합니다. C는 특정 프리미티브의 크기가 최소한 몇 바이트임을 보장합니다. C11에 stdint.h가 도입되면서 프로그래머는 정확히 몇 바이트 수의 정수 유형을 지정할 수 있으며 이는 마스크를 사용할 때 매우 유용합니다.

플래그를 설정할 때 비트 마스크가 자주 사용됩니다. 플래그는 '켜짐/꺼짐', '이동/정지' 등 두 가지 상태일 수 있는 값입니다.

## Setting bit n
비트 n을 설정하는 것은 저장 변수의 값을 2^n 값과 OR로 연결하는 것만큼 간단합니다.

    storage |= 1 << n;

예를 들어, 저장소가 문자(8비트)인 비트 3의 설정은 다음과 같습니다.

    01000010 OR 00001000 == 01001010

2^n 논리는 마스크 자체의 적절한 비트에 '1' 값을 배치하여 저장 변수의 동일한 비트에 대한 액세스를 허용합니다.

## Clearing bit n
비트 n을 지우는 것은 저장 변수의 값을 값 2^n의 역수(NOT)와 AND한 결과입니다.

    storage &= ~(1 << n);

다시 예를 들어보겠습니다.

    01001010 AND 11110111 == 01000010

## Flipping bit n
비트 n을 뒤집는 것은 저장 변수의 값을 2^n으로 XOR한 결과입니다.

    storage ^= 1 << n;

    01000010 01001010 XOR XOR 00001000 00001000 == == 01001010 01000010

## Checking bit n
비트를 확인하는 것은 2^n 값을 비트 저장소와 AND하는 것입니다.

    bit = storage & (1 << n);

    01000010 01001010 AND AND 00001000 00001000 == == 00000000 00001000